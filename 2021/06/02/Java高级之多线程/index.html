

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Java高级之多线程 - 我的小时光</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="多线程1、基本概念:程序、进程、线程
程序(progr...">
  <meta name="author" content="chen">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  
  
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_r673sha78lq.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: '[object Object]'
      },
      donate: {
        enable: true,
        alipay: 'https://www.picbed.cn/images/2021/04/30/1a97c92362332d74f.png',
        wechat: 'https://www.picbed.cn/images/2021/04/30/1cea1223e43f59565.png'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://www.picbed.cn/images/2021/04/30/mmqrcode1619760412850.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: false,
        path: 'search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
    </div>
    <div class="center">Java高级之多线程</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries/ " class="underline "> 摄影</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="https://www.picbed.cn/images/2021/04/30/160-1606471_logo-java.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">Java高级之多线程</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>June 02, 2021</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>34619</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="1、基本概念-程序、进程、线程"><a href="#1、基本概念-程序、进程、线程" class="headerlink" title="1、基本概念:程序、进程、线程"></a>1、基本概念:程序、进程、线程</h2><ul>
<li><p>程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一 段静态的代码，静态对象。 </p>
</li>
<li><p>进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态 的过程：有它自身的产生、存在和消亡的过程。——生命周期 </p>
<ul>
<li>如：运行中的QQ，运行中的MP3播放器</li>
<li>程序是静态的，进程是动态的 </li>
<li>进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域 </li>
</ul>
</li>
<li><p>线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。 </p>
<ul>
<li>若一个进程同一时间并行执行多个线程，就是支持多线程的 </li>
<li>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开 销小 </li>
<li>一个进程中的多个线程共享相同的内存单元/内存地址空间它们从同一堆中分配对象，可以 访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资 源可能就会带来安全的隐患。</li>
</ul>
</li>
</ul>
<ul>
<li>单核CPU和多核CPU的理解<ul>
<li>单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程 的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费 才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以 把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费）。但是因为CPU时 间单元特别短，因此感觉不出来。</li>
<li>如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）</li>
<li> 一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc() 垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。</li>
</ul>
</li>
<li>并行与并发<ul>
<li>并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。</li>
<li>并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。</li>
</ul>
</li>
</ul>
<h2 id="2、多线程的优点等"><a href="#2、多线程的优点等" class="headerlink" title="2、多线程的优点等"></a>2、多线程的优点等</h2><p>以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方 法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？</p>
<p>多线程的优点：</p>
<ul>
<li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验</li>
<li>提高计算机系统CPU的利用率</li>
<li>改善程序结构。将即长又复杂的进程分为多个线程，独立运行，利于理解和修改</li>
</ul>
<p>什么时候需要多线程？</p>
<ul>
<li>程序需要同时执行两个或多个任务</li>
<li>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等</li>
<li>需要一些后台运行的程序时</li>
</ul>
<h2 id="3、多线程的创建，方式一-继承于Thread类"><a href="#3、多线程的创建，方式一-继承于Thread类" class="headerlink" title="3、多线程的创建，方式一: 继承于Thread类"></a>3、多线程的创建，方式一: 继承于Thread类</h2><ul>
<li><p>Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现。</p>
</li>
<li><p>Thread类的特性</p>
<ul>
<li>每个线程都是通过某个特定的Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体</li>
<li>通过该Thread对象的start()方法来启动这个线程，而非直接调用run()</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.java;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">       多线程的创建，方式一: 继承于Thread类</span><br><span class="hljs-comment">       1、创建一个继承于Thread类的子类</span><br><span class="hljs-comment">       2、重写Thread类的run() --&gt; 将此线程执行的操作声明在run()中</span><br><span class="hljs-comment">       3、创建Thread类的子类的对象</span><br><span class="hljs-comment">       4、通过此对象调用start()</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       例子:</span><br><span class="hljs-comment">            遍历100以内的所有的偶数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">//1、创建一个继承于Thread类的子类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-comment">// 2、重写Thread类的run()</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       <span class="hljs-comment">// 3、创建Thread类的子类的对象</span><br><br>        MyThread t1 = <span class="hljs-keyword">new</span> MyThread();<br>        <span class="hljs-comment">// 4、通过此对象调用start()</span><br>        t1.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(i+<span class="hljs-string">&quot;*****main()*********&quot;</span>);<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="4、创建过程中两个问题的说明"><a href="#4、创建过程中两个问题的说明" class="headerlink" title="4、创建过程中两个问题的说明"></a>4、创建过程中两个问题的说明</h2><blockquote>
<p>4、通过此对象调用start(): ①启动当前进程 ②调用当前线程的run()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如下操作仍然是在main线程中执行的。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(i+<span class="hljs-string">&quot;*****main()*********&quot;</span>);<br><br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.java;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">       多线程的创建，方式一: 继承于Thread类</span><br><span class="hljs-comment">       1、创建一个继承于Thread类的子类</span><br><span class="hljs-comment">       2、重写Thread类的run() --&gt; 将此线程执行的操作声明在run()中</span><br><span class="hljs-comment">       3、创建Thread类的子类的对象</span><br><span class="hljs-comment">       4、通过此对象调用start()</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       例子:</span><br><span class="hljs-comment">            遍历100以内的所有的偶数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">//1、创建一个继承于Thread类的子类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-comment">// 2、重写Thread类的run()</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       <span class="hljs-comment">// 3、创建Thread类的子类的对象</span><br><br>        MyThread t1 = <span class="hljs-keyword">new</span> MyThread();<br>        <span class="hljs-comment">// 4、通过此对象调用start(): ①启动当前进程 ②调用当前线程的run()</span><br><br>        t1.start();<br><span class="hljs-comment">//问题一:  我们不能通过直接调用run()的方式启动线程</span><br>        <span class="hljs-comment">//t1.run();</span><br><br><span class="hljs-comment">//问题二: 再启动一个线程，遍历100以内的偶数.不可以还让已经start()的线程去执行。会报非法的线程状态</span><br>        <span class="hljs-comment">//t1.start();//IllegalThreadStateException非法的线程状态</span><br><br>        <span class="hljs-comment">//我们需要重新创建一个线程的对象</span><br>        MyThread t2 = <span class="hljs-keyword">new</span> MyThread();<br>        t2.start();<br>        <span class="hljs-comment">//如下操作仍然是在main线程中执行的。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(i+<span class="hljs-string">&quot;*****main()*********&quot;</span>);<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="5、线程的常用方法"><a href="#5、线程的常用方法" class="headerlink" title="5、线程的常用方法"></a>5、线程的常用方法</h2><ul>
<li>void start() : 启动线程，并执行对象的run()方法</li>
<li>run(): 线程在被调度时执行的操作</li>
<li>String getName(): 返回线程的名称</li>
<li>void setName(String name):设置该线程名称</li>
<li>static Thread currentThread(): 返回当前线程。在Thread子类中就是this,通常用于主线程和Runnable实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.exer;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">测试Thread中的常用方法</span><br><span class="hljs-comment">1、start(): 启动当前线程；调用当前线程的run()</span><br><span class="hljs-comment">2、run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</span><br><span class="hljs-comment">3、currentThread(): 静态方法。返回执行当前代码的线程</span><br><span class="hljs-comment">4、getName(): 获取当前线程的名字</span><br><span class="hljs-comment">5、setName(): 设置当前线程的名字</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">6、yield(): 释放当前cpu的执行权</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">7、join(): 在线程A中调用线程B的join(),此时线程A就进入阻塞状态，直到线程B完全执行完以后，线程A才结束阻塞状态。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">8、stop(): 已过时。当执行此方法时，强制结束当前线程。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">9、sleep(long Millittime):  让当前线程&quot;睡眠&quot;指定的Millittime毫秒。在指定的Millittime毫秒时间内，当前</span><br><span class="hljs-comment">                           线程时阻塞状态。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">10、isAlive(): 判断当前线程是否存活</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HelloThread</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    sleep(<span class="hljs-number">10</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br><br><br>            &#125;<br><br><span class="hljs-comment">//            if(i % 20 == 0)&#123;</span><br><span class="hljs-comment">//                yield();//释放执行权</span><br><span class="hljs-comment">//            &#125;</span><br>        &#125;<br><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadMethodTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        HelloThread h1 = <span class="hljs-keyword">new</span> HelloThread(<span class="hljs-string">&quot;Thread:1&quot;</span>);<br>       <span class="hljs-comment">// h1.setName(&quot;线程1&quot;);</span><br>        h1.start();<br><br>        <span class="hljs-comment">//给主线程命名</span><br>        Thread.currentThread().setName(<span class="hljs-string">&quot;主线程&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br><br>            &#125;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">20</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    h1.join();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        System.out.println(h1.isAlive());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="6、线程优先级的设置"><a href="#6、线程优先级的设置" class="headerlink" title="6、线程优先级的设置"></a>6、线程优先级的设置</h2><p>线程的调度</p>
<p>调度策略：</p>
<ul>
<li>时间片</li>
<li>抢占式: 高优先级的线程抢占CPU</li>
</ul>
<p>Java的调度方法</p>
<ul>
<li>同优先级线程组成先进先出队列(先到先服务)，使用时间片策略</li>
<li>对高优先级，使用优先调度的抢占式策略</li>
</ul>
<p>线程的优先级等级</p>
<ul>
<li>MAX_PRIORITY: 10</li>
<li>MIN_PRIORITY: 1</li>
<li>NORM_PRIORITY : 5</li>
</ul>
<p>涉及的方法：</p>
<ul>
<li>getPriority() : 返回线程优先值</li>
<li>setPriority(int newPriority):改变线程的优先级</li>
</ul>
<p>说明:</p>
<ul>
<li>线程创建时继承父线程的优先级</li>
<li>低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用</li>
</ul>
<p>idea 查看 类 所有方法的快捷键</p>
<p>Idea:ctrl+F12</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.exer;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">测试Thread中的常用方法</span><br><span class="hljs-comment">1、start(): 启动当前线程；调用当前线程的run()</span><br><span class="hljs-comment">2、run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</span><br><span class="hljs-comment">3、currentThread(): 静态方法。返回执行当前代码的线程</span><br><span class="hljs-comment">4、getName(): 获取当前线程的名字</span><br><span class="hljs-comment">5、setName(): 设置当前线程的名字</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">6、yield(): 释放当前cpu的执行权</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">7、join(): 在线程A中调用线程B的join(),此时线程A就进入阻塞状态，直到线程B完全执行完以后，线程A才结束阻塞状态。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">8、stop(): 已过时。当执行此方法时，强制结束当前线程。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">9、sleep(long Millittime):  让当前线程&quot;睡眠&quot;指定的Millittime毫秒。在指定的Millittime毫秒时间内，当前</span><br><span class="hljs-comment">                           线程时阻塞状态。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">10、isAlive(): 判断当前线程是否存活</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">线程的优先级:</span><br><span class="hljs-comment">1、- MAX_PRIORITY: 10</span><br><span class="hljs-comment">- MIN_PRIORITY: 1</span><br><span class="hljs-comment">- NORM_PRIORITY : 5 ----&gt;默认优先级</span><br><span class="hljs-comment">2、如何获取和设置当前线程的优先级:</span><br><span class="hljs-comment">    - getPriority() : 返回线程优先值</span><br><span class="hljs-comment">    - setPriority(int newPriority):改变线程的优先级</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    说明： 高优先级的线程要抢占低优先级线程cpu的执行权。</span><br><span class="hljs-comment">    但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HelloThread</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HelloThread</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br><br><span class="hljs-comment">//                try &#123;</span><br><span class="hljs-comment">//                    sleep(10);</span><br><span class="hljs-comment">//                &#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">//                    e.printStackTrace();</span><br><span class="hljs-comment">//                &#125;</span><br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+Thread.currentThread().getPriority()+<span class="hljs-string">&quot;:&quot;</span>+i);<br><br><br>            &#125;<br><br><span class="hljs-comment">//            if(i % 20 == 0)&#123;</span><br><span class="hljs-comment">//                yield();//释放执行权</span><br><span class="hljs-comment">//            &#125;</span><br>        &#125;<br><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadMethodTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        HelloThread h1 = <span class="hljs-keyword">new</span> HelloThread(<span class="hljs-string">&quot;Thread:1&quot;</span>);<br>       <span class="hljs-comment">// h1.setName(&quot;线程1&quot;);</span><br><br>        <span class="hljs-comment">//设置分线程的优先级</span><br>        h1.setPriority(Thread.MAX_PRIORITY);<br><br>        h1.start();<br><br>        <span class="hljs-comment">//给主线程命名</span><br>        Thread.currentThread().setName(<span class="hljs-string">&quot;主线程&quot;</span>);<br>        Thread.currentThread().setPriority(Thread.MIN_PRIORITY);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+Thread.currentThread().getPriority()+<span class="hljs-string">&quot;:&quot;</span>+i);<br><br>            &#125;<br><span class="hljs-comment">//            if(i == 20)&#123;</span><br><span class="hljs-comment">//                try &#123;</span><br><span class="hljs-comment">//                    h1.join();</span><br><span class="hljs-comment">//                &#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">//                    e.printStackTrace();</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//            &#125;</span><br>        &#125;<br><br><span class="hljs-comment">//        System.out.println(h1.isAlive());</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>





<h2 id="7、多线程的创建，方式二-实现Runnable"><a href="#7、多线程的创建，方式二-实现Runnable" class="headerlink" title="7、多线程的创建，方式二: 实现Runnable"></a>7、多线程的创建，方式二: 实现Runnable</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.java;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">       创建多线程的方式二: 实现Runnable接口</span><br><span class="hljs-comment">       1、创建了一个实现了Runnable接口的类</span><br><span class="hljs-comment">       2、实现类去实现Runnable中的抽象方法: run()</span><br><span class="hljs-comment">       3、创建实现类的对象</span><br><span class="hljs-comment">       4、将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span><br><span class="hljs-comment">       5、通过Thread类的对象调用start()</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//1、创建了一个实现了Runnable接口的类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br><span class="hljs-comment">//2、实现类去实现Runnable中的抽象方法: run()</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>           <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>               System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>           &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest1</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//3、创建实现类的对象</span><br>        MThread mThread = <span class="hljs-keyword">new</span> MThread();<br><br><br>       <span class="hljs-comment">// 4、将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(mThread);<br><br>        <span class="hljs-comment">//5、通过Thread类的对象调用start() ①启动线程 ②调用当前线程的run()---&gt;调用了Runnable类型的target的run()</span><br><br>        t1.start();<br><br>        <span class="hljs-comment">//再启动一个线程，遍历一百以内的偶数</span><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(mThread);<br>        t2.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="8、比较创建线程的两种方式"><a href="#8、比较创建线程的两种方式" class="headerlink" title="8、比较创建线程的两种方式"></a>8、比较创建线程的两种方式</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">比较创建线程的两种方式：<br>开发中优先选择实现Runnable接口的方式<br>原因<span class="hljs-number">1</span>:<br>    <span class="hljs-number">1</span>、实现的方式没有类的单继承性的局限性<br>    <span class="hljs-number">2</span>、实现的方式更适合来处理多个线程有共享数据的情况。<br><br>联系：<br><span class="hljs-keyword">public</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Thread</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Runnable</span><br>相同点: 两种方式都需要重写<span class="hljs-symbol">run</span>(),将线程要执行的逻辑声明在<span class="hljs-symbol">run</span>()中。<br></code></pre></td></tr></table></figure>

<h2 id="9、线程的生命周期"><a href="#9、线程的生命周期" class="headerlink" title="9、线程的生命周期"></a>9、线程的生命周期</h2><p>JDK中用Thread.State类定义了线程的几种状态</p>
<p>要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类 及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五 种状态：</p>
<ul>
<li>新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建 状态</li>
<li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已 具备了运行的条件，只是没分配到CPU资源</li>
<li>运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线 程的操作和功能</li>
<li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中 止自己的执行，进入阻塞状态</li>
<li>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li>
</ul>
<p><img   class="lazyload" data-original="https://www.picbed.cn/images/2021/06/03/1.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ></p>
<h2 id="10、线程的安全问题"><a href="#10、线程的安全问题" class="headerlink" title="10、线程的安全问题"></a>10、线程的安全问题</h2><ul>
<li>问题的提出:<ul>
<li>多个线程执行的不确定性引起执行结果的不稳定</li>
<li>多个线程对账本的共享，会造成操作的不完整性，会破坏数据。</li>
</ul>
</li>
</ul>
<p>线程安全问题举例及解决措施</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> test.java;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 例子：创建三个窗口卖票，总票数为100张.使用实现Runnable接口的方式</span><br><span class="hljs-comment"> * 存在线程的安全问题，待解决。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1、问题: 买票过程中，出现了重票、错票 ---&gt; 出现了线程的安全问题</span><br><span class="hljs-comment"> * 2、问题出现的原因:</span><br><span class="hljs-comment"> *      当某个线程操作车票过程中，尚未操作完成时，其它线程参与进来，也操作车票。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3、如何解决？</span><br><span class="hljs-comment"> *      当一个线程在操作ticket的时候，其它线程不能参与进来。直到线程A操作完ticket时，</span><br><span class="hljs-comment"> *      线程才可以开始操作ticket。这种情况即使线程A出现了阻塞，也不能被改变。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *4、在Java中，我们通过同步机制，来解决线程的安全问题。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *      方式一: 同步代码块</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *          synchronized(同步监视器)&#123;</span><br><span class="hljs-comment"> *              //需要被同步的代码</span><br><span class="hljs-comment"> *          &#125;</span><br><span class="hljs-comment"> *          说明:</span><br><span class="hljs-comment"> *             1、 操作共享数据的代码，即为需要被同步的代码. ---&gt;不能包含代码多了，也不能包含少了。</span><br><span class="hljs-comment"> *             2、共享数据: 多个线程共同操作的变量。比如：ticket就是共享数据。</span><br><span class="hljs-comment"> *             3、同步监视器，俗称: 锁。任何一个类的对象，都可以充当是锁。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *             要求:</span><br><span class="hljs-comment"> *                  多个线程必须要共用同一把锁</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *           补充: 在实现Runable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器</span><br><span class="hljs-comment"> *      方式二：同步方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *          &#123;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *          &#125;</span><br><span class="hljs-comment"> *5、同步的方式，解决了线程的安全问题  ---好处</span><br><span class="hljs-comment"> *  操作同步代码时，只能有一个线程参与，其它线程等待。相当于是一个单线程的过程，效率低。 ---局限性</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">100</span>;<br><br>    Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//  Object obj = new Object();必须是多个线程必须要共用同一把锁</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (obj) &#123;<span class="hljs-comment">// synchronized (this) &#123;//obj 此时的this:唯一的window1的对象  //方式二:synchronized (dog)</span><br>                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br><br><br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:卖票，票号为：&quot;</span> + ticket);<br>                    ticket--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowTest1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Window1 w = <span class="hljs-keyword">new</span> Window1();<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(w);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(w);<br>        Thread t3 = <span class="hljs-keyword">new</span> Thread(w);<br><br>        t1.setName(<span class="hljs-string">&quot;窗口1&quot;</span>);<br>        t2.setName(<span class="hljs-string">&quot;窗口2&quot;</span>);<br>        t3.setName(<span class="hljs-string">&quot;窗口3&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t3.start();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>WindowTest1.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> test.java2;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 通过同步代码块，来解决继承Thread类的方式的线程安全问题。</span><br><span class="hljs-comment"> * 例子：创建三个窗口卖票，总票数为100张.使用继承Thread类的方式</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 说明: 在继承Thread类创建多线程的方式中，慎用this充当同步监视器。</span><br><span class="hljs-comment"> *考虑使用当前类充当同步监视器。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br><br>            <span class="hljs-keyword">synchronized</span> (Window2.class)&#123;<span class="hljs-comment">//Class clazz = Window2.class;</span><br>                <span class="hljs-comment">//Window2.class只会加载一次</span><br>            <span class="hljs-comment">//synchronized (obj)&#123;</span><br>                <span class="hljs-comment">//synchronized (this)错误此时this代表着t1,t2,t3三个对象</span><br>                <span class="hljs-keyword">if</span>(ticket &gt; <span class="hljs-number">0</span>)&#123;<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br><br>                    System.out.println(getName() + <span class="hljs-string">&quot;：卖票，票号为：&quot;</span> + ticket);<br>                    ticket--;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br><br><br>        &#125;<br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowTest2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Window2 t1 = <span class="hljs-keyword">new</span> Window2();<br>        Window2 t2 = <span class="hljs-keyword">new</span> Window2();<br>        Window2 t3 = <span class="hljs-keyword">new</span> Window2();<br><br><br>        t1.setName(<span class="hljs-string">&quot;窗口1&quot;</span>);<br>        t2.setName(<span class="hljs-string">&quot;窗口2&quot;</span>);<br>        t3.setName(<span class="hljs-string">&quot;窗口3&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>









<p>同步方法处理实现Runnable的线程安全问题</p>
<p>WindowTest3.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.java;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    同步方法处理实现Runnable的线程安全问题</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    关于同步方法的总结:</span><br><span class="hljs-comment">        1、同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</span><br><span class="hljs-comment">        2、非静态的同步方法，同步监视器是:this</span><br><span class="hljs-comment">            静态的同步方法，同步监视器是: 当前类本身</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">100</span>;<br><br>    Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><br>            show();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span>  <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//同步监视器: this</span><br><br>        <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:卖票，票号为：&quot;</span> + ticket);<br>            ticket--;<br>        &#125;<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowTest3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Window3 w = <span class="hljs-keyword">new</span> Window3();<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(w);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(w);<br>        Thread t3 = <span class="hljs-keyword">new</span> Thread(w);<br><br>        t1.setName(<span class="hljs-string">&quot;窗口1&quot;</span>);<br>        t2.setName(<span class="hljs-string">&quot;窗口2&quot;</span>);<br>        t3.setName(<span class="hljs-string">&quot;窗口3&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t3.start();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>WindowTest4.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.java;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 同步方法处理继承Thread类的方式中的线程安全问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window4</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            show();<br>        &#125;<br><br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//同步监视器： Window4.class</span><br>        <span class="hljs-comment">//private synchronized void show()&#123;//同步监视器: t1,t2,t3 此种解决方式是错误的</span><br><br>            <span class="hljs-keyword">if</span>(ticket &gt; <span class="hljs-number">0</span>)&#123;<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;：卖票，票号为：&quot;</span> + ticket);<br>                ticket--;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowTest4</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Window4 t1 = <span class="hljs-keyword">new</span> Window4();<br>        Window4 t2 = <span class="hljs-keyword">new</span> Window4();<br>        Window4 t3 = <span class="hljs-keyword">new</span> Window4();<br><br><br>        t1.setName(<span class="hljs-string">&quot;窗口1&quot;</span>);<br>        t2.setName(<span class="hljs-string">&quot;窗口2&quot;</span>);<br>        t3.setName(<span class="hljs-string">&quot;窗口3&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="11、线程安全的单例模式之懒汉式"><a href="#11、线程安全的单例模式之懒汉式" class="headerlink" title="11、线程安全的单例模式之懒汉式"></a>11、线程安全的单例模式之懒汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.java1;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    使用同步机制将单例模式中的懒汉式改写为线程安全的</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BankTest</span> </span>&#123;<br><br><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bank</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Bank</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bank instance = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  Bank <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//synchronized</span><br><br>        <span class="hljs-comment">//方式一:效率稍差</span><br><span class="hljs-comment">//        synchronized (Bank.class) &#123;//选定代码块，快捷键： Ctrl+Alt+T</span><br><span class="hljs-comment">//            if(instance == null)&#123;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//                instance = new Bank();</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//            return instance;</span><br><span class="hljs-comment">//        &#125;</span><br><br>        <span class="hljs-comment">//方式二:效率更高</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (Bank.class) &#123;<span class="hljs-comment">//选定代码块，快捷键： Ctrl+Alt+T</span><br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>)&#123;<br><br>                    instance = <span class="hljs-keyword">new</span> Bank();<br><br>                &#125;<br><br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="12、线程的死锁问题"><a href="#12、线程的死锁问题" class="headerlink" title="12、线程的死锁问题"></a>12、线程的死锁问题</h2><p>死锁:</p>
<ul>
<li>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</li>
<li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</li>
</ul>
<p>解决方法:</p>
<ul>
<li>专门的算法、原则</li>
<li>尽量减少同步资源的定义</li>
<li>尽量避免嵌套同步</li>
</ul>
<p>DeadLock.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.java1;<br><span class="hljs-comment">//死锁的演示</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(B b)</span> </span>&#123;<span class="hljs-comment">//同步监视器: A类的对象: a</span><br>		System.out.println(<span class="hljs-string">&quot;当前线程名: &quot;</span> + Thread.currentThread().getName()<br>				+ <span class="hljs-string">&quot; 进入了A实例的foo方法&quot;</span>); <span class="hljs-comment">// ①</span><br>		<span class="hljs-keyword">try</span> &#123;<br>			Thread.sleep(<span class="hljs-number">200</span>);<br>		&#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>			ex.printStackTrace();<br>		&#125;<br>		System.out.println(<span class="hljs-string">&quot;当前线程名: &quot;</span> + Thread.currentThread().getName()<br>				+ <span class="hljs-string">&quot; 企图调用B实例的last方法&quot;</span>); <span class="hljs-comment">// ③</span><br>		b.last();<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">last</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//同步监视器: A类的对象: a</span><br>		System.out.println(<span class="hljs-string">&quot;进入了A类的last方法内部&quot;</span>);<br>	&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(A a)</span> </span>&#123;<span class="hljs-comment">//同步监视器: b</span><br>		System.out.println(<span class="hljs-string">&quot;当前线程名: &quot;</span> + Thread.currentThread().getName()<br>				+ <span class="hljs-string">&quot; 进入了B实例的bar方法&quot;</span>); <span class="hljs-comment">// ②</span><br>		<span class="hljs-keyword">try</span> &#123;<br>			Thread.sleep(<span class="hljs-number">200</span>);<br>		&#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>			ex.printStackTrace();<br>		&#125;<br>		System.out.println(<span class="hljs-string">&quot;当前线程名: &quot;</span> + Thread.currentThread().getName()<br>				+ <span class="hljs-string">&quot; 企图调用A实例的last方法&quot;</span>); <span class="hljs-comment">// ④</span><br>		a.last();<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">last</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//同步监视器: b</span><br>		System.out.println(<span class="hljs-string">&quot;进入了B类的last方法内部&quot;</span>);<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>	A a = <span class="hljs-keyword">new</span> A();<br>	B b = <span class="hljs-keyword">new</span> B();<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>		Thread.currentThread().setName(<span class="hljs-string">&quot;主线程&quot;</span>);<br>		<span class="hljs-comment">// 调用a对象的foo方法</span><br>		a.foo(b);<br>		System.out.println(<span class="hljs-string">&quot;进入了主线程之后&quot;</span>);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		Thread.currentThread().setName(<span class="hljs-string">&quot;副线程&quot;</span>);<br>		<span class="hljs-comment">// 调用b对象的bar方法</span><br>		b.bar(a);<br>		System.out.println(<span class="hljs-string">&quot;进入了副线程之后&quot;</span>);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		DeadLock dl = <span class="hljs-keyword">new</span> DeadLock();<br>		<span class="hljs-keyword">new</span> Thread(dl).start();<br>		dl.init();<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>ThreadTest.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.java1;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    演示线程的死锁问题</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    1、死锁的理解:</span><br><span class="hljs-comment">        不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    2、说明：</span><br><span class="hljs-comment">    1） 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</span><br><span class="hljs-comment">    2)  我们使用同步时，要避免出现死锁。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br><br>        StringBuffer s1 = <span class="hljs-keyword">new</span> StringBuffer();<br>        StringBuffer s2 = <span class="hljs-keyword">new</span> StringBuffer();<br><br><br>        <span class="hljs-keyword">new</span> Thread()&#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br><br>                <span class="hljs-keyword">synchronized</span> (s1)&#123;<br>                    s1.append(<span class="hljs-string">&quot;a&quot;</span>);<br>                    s2.append(<span class="hljs-string">&quot;1&quot;</span>);<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br><br>                    <span class="hljs-keyword">synchronized</span> (s2)&#123;<br>                        s1.append(<span class="hljs-string">&quot;b&quot;</span>);<br>                        s2.append(<span class="hljs-string">&quot;2&quot;</span>);<br>                        System.out.println(s1);<br>                        System.out.println(s2);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>        &#125;.start();<br><br>        <span class="hljs-keyword">new</span> Thread(<br>                <span class="hljs-keyword">new</span> Runnable() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                        <span class="hljs-keyword">synchronized</span> (s2)&#123;<br><br>                            <span class="hljs-keyword">try</span> &#123;<br>                                Thread.sleep(<span class="hljs-number">100</span>);<br>                            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                                e.printStackTrace();<br>                            &#125;<br>                            s1.append(<span class="hljs-string">&quot;c&quot;</span>);<br>                            s2.append(<span class="hljs-string">&quot;3&quot;</span>);<br>                            <span class="hljs-keyword">synchronized</span> (s1)&#123;<br>                                s1.append(<span class="hljs-string">&quot;d&quot;</span>);<br>                                s2.append(<span class="hljs-string">&quot;4&quot;</span>);<br>                                System.out.println(s1);<br>                                System.out.println(s2);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>        ).start();<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="13、Lock锁方式解决线程安全问题"><a href="#13、Lock锁方式解决线程安全问题" class="headerlink" title="13、Lock锁方式解决线程安全问题"></a>13、Lock锁方式解决线程安全问题</h2><p>Lock(锁)</p>
<ul>
<li>从JDK 5.0开始，Java提供了更强大的线程同步机制 —- 通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</li>
<li><strong>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。</strong>锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</li>
<li>ReentrantLock类实现了Lock,它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</li>
</ul>
<p>synchronized 与 Lock的对比:</p>
<p>1、Lock是显式锁(手动开启和关闭锁，不要忘记关闭锁)，synchronized是隐式锁，出了作用域自动释放</p>
<p>2、Lock只有代码块锁，synchronized有代码块和方法锁</p>
<p>3、使用Lock锁，JVM将花费较少的时间来调度线程，性能能更好。并且具有更好的扩展性(提供更多的子类)</p>
<ul>
<li>优先使用顺序</li>
</ul>
<p>Lock – &gt;同步代码块(已经进入了方法体，分配了相应资源)—&gt;同步方法(在方法体之外)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.java1;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    解决线程安全问题的方式三: Lock锁 --- JDK5.0新增</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    1、面试题:synchronized 与 Lock的异同？</span><br><span class="hljs-comment">        同: 二者都可以解决线程安全问题</span><br><span class="hljs-comment">        不同: synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器</span><br><span class="hljs-comment">        Lock需要手动的启动同步（lock()）,同时结束同步也需要手动的实现(unlock())</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    2、优先使用顺序</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Lock -- &gt;同步代码块(已经进入了方法体，分配了相应资源)---&gt;同步方法(在方法体之外)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	面试题:如何解决线程安全问题？有几种方式</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-comment">//1、实例化ReentrantLock</span><br>    <span class="hljs-keyword">private</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-comment">//2、调用锁定方法lock()</span><br>                lock.lock();<br>                <span class="hljs-keyword">if</span>(ticket &gt; <span class="hljs-number">0</span>)&#123;<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;售票，票号为:&quot;</span>+ticket);<br>                    ticket--;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">//3、调用解锁方法: unlock()</span><br>                lock.unlock();<br>            &#125;<br><br>        &#125;<br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Window w = <span class="hljs-keyword">new</span> Window();<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(w);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(w);<br>        Thread t3 = <span class="hljs-keyword">new</span> Thread(w);<br><br>        t1.setName(<span class="hljs-string">&quot;窗口1&quot;</span>);<br>        t2.setName(<span class="hljs-string">&quot;窗口2&quot;</span>);<br>        t3.setName(<span class="hljs-string">&quot;窗口3&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="14、线程的通信"><a href="#14、线程的通信" class="headerlink" title="14、线程的通信"></a>14、线程的通信</h2><p>例题:使用两个线程打印1-100。 线程1，线程2 交替打印</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.java2;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    线程通信的例子: 使用两个线程打印1-100.线程1，线程2交替打印</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    涉及到三个方法:</span><br><span class="hljs-comment">    wait(): 一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    notify():</span><br><span class="hljs-comment">        一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait,就唤醒优先级高的那个。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    notifyAll():</span><br><span class="hljs-comment">        一旦执行此方法，就会唤醒所有被wait的线程。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    说明:</span><br><span class="hljs-comment">       1、wait(),notify(),notifyAll(),三个方法必须使用在同步代码块或同步方法中。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       2、wait(),notify(),notifyAll(),三个方法的调用者必须是同步代码块或同步方法中的同步监视器。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">          否则。会出现IllegalMonitorStateException</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        3、wait(),notify(),notifyAll(),三个方法是定义在java.lang.Object类中。</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//private Object obj = new Object();</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br><br>                notify();<br>                <span class="hljs-keyword">if</span>(number &lt;= <span class="hljs-number">100</span>)&#123;<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">10</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+number);<br>                    number++;<br><br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">//使得调用如下wait()方法的线程进入阻塞状态</span><br>                        wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComunicationTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Number number = <span class="hljs-keyword">new</span> Number();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(number);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(number);<br><br>        t1.setName(<span class="hljs-string">&quot;线程1&quot;</span>);<br>        t2.setName(<span class="hljs-string">&quot;线程2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="15、sleep-和wait-的异同"><a href="#15、sleep-和wait-的异同" class="headerlink" title="15、sleep()和wait()的异同"></a>15、sleep()和wait()的异同</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">面试题: sleep() 和 wait()的异同？</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        1、相同点: 一旦执行方法，都可以使得当前的线程进入阻塞状态。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        2、不同点:</span><br><span class="hljs-comment">            - 两个方法声明的位置不同： Thread类中声明sleep(),Object类中声明wait()</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            - 调用的要求不同:</span><br><span class="hljs-comment">                    可以在任何需要的场景下调用。wait()必须使用在同步代码块或同步方法中</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            - 关于是否释放同步监视器:如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<h2 id="16、线程通信例题-生产者-消费者问题"><a href="#16、线程通信例题-生产者-消费者问题" class="headerlink" title="16、线程通信例题: 生产者/消费者问题"></a>16、线程通信例题: 生产者/消费者问题</h2><p>生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处 取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图 生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通 知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如 果店中有产品了再通知消费者来取走产品。</p>
<p>这里可能出现两个问题：</p>
<ul>
<li>生产者比消费者快时，消费者会漏掉一些数据没有取到。</li>
<li>消费者比生产者快时，消费者会取相同的数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.java3;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    线程通信的应用: 经典例题: 生产者/消费者问题</span><br><span class="hljs-comment">        生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处 取走产品，</span><br><span class="hljs-comment">        店员一次只能持有固定数量的产品(比如:20），如果生产者试图 生产更多的产品，</span><br><span class="hljs-comment">        店员会叫生产者停一下，如果店中有空位放产品了再通 知生产者继续生产；</span><br><span class="hljs-comment">        如果店中没有产品了，店员会告诉消费者等一下，如 果店中有产品了再通知消费者来取走产品。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">分析:</span><br><span class="hljs-comment">   1、是否为多线程？</span><br><span class="hljs-comment">        是，生产者线程，消费者线程</span><br><span class="hljs-comment">   2、是否有共享数据？</span><br><span class="hljs-comment">        是，产品数量</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   3、如何解决线程安全问题？同步机制，三种方法</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   4、是否涉及到线程的·通信？</span><br><span class="hljs-comment">        是</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clerk</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> productCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//生产产品</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produceProduct</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(productCount &lt; <span class="hljs-number">20</span>)&#123;<br>            productCount++;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:开始生产第&quot;</span>+productCount+<span class="hljs-string">&quot;个产品&quot;</span>);<br><br>            notify();<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-comment">//消费产品</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeProduct</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(productCount &gt; <span class="hljs-number">0</span>)&#123;<br><br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:开始消费第&quot;</span>+productCount+<span class="hljs-string">&quot;个产品&quot;</span>);<br>            productCount--;<br><br>            notify();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<span class="hljs-comment">//生产者</span><br><br>    <span class="hljs-keyword">private</span> Clerk clerk;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Producer</span><span class="hljs-params">(Clerk clerk)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.clerk = clerk;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(getName()+<span class="hljs-string">&quot;开始生产产品......&quot;</span>);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            clerk.produceProduct();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<span class="hljs-comment">//消费者</span><br>    <span class="hljs-keyword">private</span> Clerk clerk;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(Clerk clerk)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.clerk = clerk;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(getName()+<span class="hljs-string">&quot;开始消费产品......&quot;</span>);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep(<span class="hljs-number">20</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            clerk.consumeProduct();<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Clerk clerk = <span class="hljs-keyword">new</span> Clerk();<br><br>        Producer p1 = <span class="hljs-keyword">new</span> Producer(clerk);<br>        p1.setName(<span class="hljs-string">&quot;生产者1&quot;</span>);<br><br>        Producer p2 = <span class="hljs-keyword">new</span> Producer(clerk);<br>        p2.setName(<span class="hljs-string">&quot;生产者2&quot;</span>);<br><br>        Consumer c1 = <span class="hljs-keyword">new</span> Consumer(clerk);<br>        c1.setName(<span class="hljs-string">&quot;消费者1&quot;</span>);<br><br>        Consumer c2 = <span class="hljs-keyword">new</span> Consumer(clerk);<br>        c2.setName(<span class="hljs-string">&quot;消费者2&quot;</span>);<br><br>        p1.start();<br>        c1.start();<br>        c2.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="17、JDK5-0新增线程创建方式"><a href="#17、JDK5-0新增线程创建方式" class="headerlink" title="17、JDK5.0新增线程创建方式"></a>17、JDK5.0新增线程创建方式</h2><p>新增方式一: 实现Callable接口</p>
<ul>
<li> 与使用Runnable相比， Callable功能更强大些</li>
<li>相比run()方法，可以有返回值</li>
<li>方法可以抛出异常</li>
<li>支持泛型的返回值</li>
<li> 需要借助FutureTask类，比如获取返回结果</li>
</ul>
<p> Future接口</p>
<ul>
<li>可以对具体Runnable、Callable任务的执行结果进行取消、查询是 否完成、获取结果等。</li>
<li>FutrueTask是Futrue接口的唯一的实现类</li>
<li>FutureTask 同时实现了Runnable, Future接口。它既可以作为 Runnable被线程执行，又可以作为Future得到Callable的返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.java3;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    创建线程的方式三: 实现Callable接口。 ------JDK 5.0新增</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？</span><br><span class="hljs-comment">       1、call()可以有返回值的。</span><br><span class="hljs-comment">       2、call()可以抛出异常。被外面的操作捕获，获取异常的信息</span><br><span class="hljs-comment">       3、Callable是支持泛型的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//1、创建一个实现Callable的实现类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span> </span>&#123;<br><br>    <span class="hljs-comment">//2、实现call方法，将此线程需要执行的操作声明在call()中</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(i);<br>                sum += i;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadNew</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//3、创建Callable接口实现类的对象</span><br>        NumThread numThread = <span class="hljs-keyword">new</span> NumThread();<br><br><br>        <span class="hljs-comment">//4、将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span><br>        FutureTask futureTask = <span class="hljs-keyword">new</span> FutureTask(numThread);<br><br>        <span class="hljs-comment">//5、将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span><br><br>        <span class="hljs-keyword">new</span> Thread(futureTask).start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//6、获取Callable中call方法的返回值</span><br>            <span class="hljs-comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span><br>            Object sum = futureTask.get();<br>            System.out.println(<span class="hljs-string">&quot;总和为:&quot;</span>+sum);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>







<p>新增方式二：使用线程池</p>
<ul>
<li>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程， 对性能影响很大。</li>
<li> 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完 放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交 通工具。</li>
<li>好处:<ul>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li>
<li>便于线程管理<ul>
<li>corePoolSize：核心池的大小 </li>
<li> maximumPoolSize：最大线程数 </li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
<li>……</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>线程池相关API</p>
<p>JDK 5.0起提供了线程池相关API：ExecutorService 和 Executors</p>
<p>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor </p>
<ul>
<li> void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行 Runnable </li>
<li>Future submit(Callable task)：执行任务，有返回值，一般又来执行 Callable </li>
<li> void shutdown() ：关闭连接池</li>
</ul>
<p>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池 </p>
<ul>
<li>Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池 </li>
<li> Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池 </li>
<li> Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池 </li>
<li> Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运 行命令或者定期地执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.java3;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    创建线程的方式四： 使用线程池</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    -   1、 提高响应速度（减少了创建新线程的时间）</span><br><span class="hljs-comment">    -   2、降低资源消耗（重复利用线程池中线程，不需要每次都创建）</span><br><span class="hljs-comment">    -   3、便于线程管理</span><br><span class="hljs-comment">        - corePoolSize：核心池的大小</span><br><span class="hljs-comment">        -  maximumPoolSize：最大线程数</span><br><span class="hljs-comment">        - keepAliveTime：线程没有任务时最多保持多长时间后会终止</span><br><span class="hljs-comment">        - ......</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">面试题:创建多线程有几种方式？四种！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberThread1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//1、提供指定线程数量的线程池</span><br>        ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;<br>        <span class="hljs-comment">//设置线程池的属性</span><br>        service1.setCorePoolSize(<span class="hljs-number">15</span>);<br>       <span class="hljs-comment">// service1.setKeepAliveTime();</span><br><br><br>        <span class="hljs-comment">//System.out.println(service.getClass());</span><br><br><br>        <span class="hljs-comment">//2、执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span><br>        service.execute(<span class="hljs-keyword">new</span> NumberThread());<span class="hljs-comment">//适合适用于Runnable</span><br>        service.execute(<span class="hljs-keyword">new</span> NumberThread1());<span class="hljs-comment">//适合适用于Runnable</span><br><span class="hljs-comment">//        service.submit(Callable callable);//适合使用于Callable</span><br><br>        <span class="hljs-comment">//3、关闭连接池</span><br>        service.shutdown();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>


      </section>
      <section class="extra">
        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img   class="lazyload" data-original="https://www.picbed.cn/images/2021/04/30/1a97c92362332d74f.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul> 

        
  <nav class="nav">
    <a href="/2021/06/02/IDEA/"><i class="iconfont iconleft"></i>IDEA</a>
    <a href="/2021/06/02/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/">异常处理<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="toc-text">1、基本概念:程序、进程、线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%E7%AD%89"><span class="toc-text">2、多线程的优点等</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%8C%E6%96%B9%E5%BC%8F%E4%B8%80-%E7%BB%A7%E6%89%BF%E4%BA%8EThread%E7%B1%BB"><span class="toc-text">3、多线程的创建，方式一: 继承于Thread类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-text">4、创建过程中两个问题的说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">5、线程的常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-text">6、线程优先级的设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%8C%E6%96%B9%E5%BC%8F%E4%BA%8C-%E5%AE%9E%E7%8E%B0Runnable"><span class="toc-text">7、多线程的创建，方式二: 实现Runnable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E6%AF%94%E8%BE%83%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">8、比较创建线程的两种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">9、线程的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">10、线程的安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-text">11、线程安全的单例模式之懒汉式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-text">12、线程的死锁问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81Lock%E9%94%81%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">13、Lock锁方式解决线程安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">14、线程的通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81sleep-%E5%92%8Cwait-%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">15、sleep()和wait()的异同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%BE%8B%E9%A2%98-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">16、线程通信例题: 生产者&#x2F;消费者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81JDK5-0%E6%96%B0%E5%A2%9E%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-text">17、JDK5.0新增线程创建方式</span></a></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=858144715 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="https://github.com/CodeTestC "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:858144715@qq.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>